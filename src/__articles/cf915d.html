<div id="main">
    <div class="inner">
        <header id="header">
            <a href="index.html" class="logo"><strong>iHello, my World!</strong></a>
        </header>
            
        <section>
            <header class="main">
                <h1>【图论】有向图的深度优先搜索与判环</h1>
            </header>
            <h2>引出</h2>
            <p>
                最近在Codeforces上做了一场Educational Contest，确实学到了一些新东西，对以前觉得比较玄学的关于<b>有向图的深度优先搜索</b>有了一些新的认识。我们先来看题。<br />
                <a href="http://codeforces.com/contest/915/problem/D">题目链接</a><
            </p>
            <h2>题意</h2>
            <p>
                给定一张有向图，如果可以任意删去图中的一条边，问是否可以得到一张有向无环图（DAG）。<br />
                原图不一定联通，得到的图也不一定要联通。原图中可能出现重边、自环。<br />
                数据范围：点数N ≤ 500，边数M ≤ 10 0000，时间限制1秒。
            </p>
            <p>
                这个问题看上去简洁小巧，最终得到的程序也是精炼优美，但是中间的思考过程比较复杂。我们不妨先从有向图判环的问题开始说起。
            </p>
            <h2>有向图判环</h2>
            <p>
                如果一张有向图中没有环，那它顾名思义就是一张有向无环图。而有向无环图具有许多优秀的性质，比如说我们可以对图进行<a href="https://en.wikipedia.org/wiki/Topological_sorting">拓扑排序</a>。简单地说，我们可以将图的所有节点放进一个小顶堆中，按照顶点的入度排序。每次取出入度为0的一个顶点并记录，然后将从该点出发的所有边能够到达的点的入度减一；如果重复一直到所有点都被取出，则拓扑排序完成，如果某一次循环后发现没有入度为0的点，那么剩下的所有点一定构成了若干个环，或者说属于若干个强联通分量。这个算法的复杂度是O(M*log N)，假如我们的小顶堆是用二叉堆来实现的。<br />
                我们当然也可以使用<a href="https://en.wikipedia.org/wiki/Depth-first_search">深度优先搜索</a>来判断一个有向图是否有环。先任取一个顶点，从该顶点开始进行dfs，每次经过一个节点都将该节点标记为“已经被经过了”。如果发现当前节点出发有一条边连向一个已经被经过了的点，那么我们就发现了一个环。一次dfs结束后，如果没有发现环，由于图未必联通，再要任取一个没有被经过过的点进行一次dfs，直到每个点都被经过了。如果发现的环的数量为0，那么就说明图中不存在环。如果采用邻接表的形式存储图，复杂度是O(M+N)，而如果采用邻接矩阵的形式，复杂度是O(N^2)的。
            </p>
            
        </section>
    </div>
</div>
